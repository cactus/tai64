// Copyright (c) 2012-2016 Eli Janssen
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"flag"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"
	"path"
	"strconv"
	"strings"
	"time"
)

const tplText = `
// Copyright (c) 2012-2016 Eli Janssen
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

// THIS FILE IS AUTOGENERATED. DO NOT EDIT!

package {{.Pkg}}

// http://maia.usno.navy.mil/ser7/tai-utc.dat
// http://www.stjarnhimlen.se/comp/time.html
var tia64nDifferences = []struct {
    // TAI time
    ttime int64
    // TAI-UTC offset
	offset int64
    // unix UTC time
	utime int64
}{
	{{- range .Entries}}
	{{"{"}}0x{{.Tts|printf "%x"}}, {{.Drift}}, {{.Ts}}{{"}"}}, // {{.TsD}}
	{{- end}}
}

var tia64nSize = len(tia64nDifferences)
`

type srcFile struct {
	Pkg     string
	Entries []entry
}

type entry struct {
	Ts    int64
	TsD   string
	Drift int64
	Tts   int64
}

func main() {
	var output, input, pkg string
	flag.StringVar(&output, "output", "", "output file")
	flag.StringVar(&input, "input", "", "input file")
	flag.StringVar(&pkg, "pkg", "", "package name")
	flag.Parse()

	if output == "" {
		log.Fatal("Output option is required")
	}

	if pkg == "" {
		log.Fatal("Package option is required")
	}

	var br *bufio.Reader
	if input == "" {
		input = "http://maia.usno.navy.mil/ser7/tai-utc.dat"
		resp, err := http.Get(input)
		if err != nil {
			log.Fatalf("Error fetching tai-utc.dat: %s", err)
		}
		defer resp.Body.Close()
		br = bufio.NewReader(resp.Body)
	} else {
		f, err := os.Open(input)
		if err != nil {
			log.Fatalf("Cant open file: %s", err)
		}
		defer f.Close()
		br = bufio.NewReader(f)
	}

	fmt.Printf("Generating %s based on %s\n", path.Base(output), path.Base(input))

	t, err := template.New("fileTemplate").Parse(strings.TrimLeft(tplText, "\n"))
	if err != nil {
		log.Fatal(err)
	}

	entries := make([]entry, 0)

	for {
		line, err := br.ReadString('\n')
		if err != nil {
			break
		}

		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		parts := strings.Fields(line)
		t, err := time.Parse("2006 Jan 2", strings.Title(strings.Join(parts[0:3], " ")))
		if err != nil {
			fmt.Println(err)
			continue
		}

		if t.Before(time.Date(1972, 1, 1, 0, 0, 0, 0, time.UTC)) {
			continue
		}

		s, err := strconv.ParseFloat(parts[6], 32)
		if err != nil {
			fmt.Println(err)
			continue
		}
		// just truncate the float to int
		unixT := t.Unix()
		taiT := (2 << 61) + unixT + int64(s)
		e := entry{unixT, t.Format(time.RFC3339), int64(s), taiT}
		entries = append(entries, e)
	}

	w, err := os.Create(output)
	if err != nil {
		log.Fatal(err)
	}
	defer w.Close()

	writer := bufio.NewWriter(w)
	defer writer.Flush()

	srcfile := &srcFile{pkg, entries}
	err = t.Execute(writer, srcfile)
	if err != nil {
		log.Fatal(err)
	}

}
